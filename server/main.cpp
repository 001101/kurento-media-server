/*
 * (C) Copyright 2013 Kurento (http://kurento.org/)
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser General Public License
 * (LGPL) version 2.1 which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl-2.1.html
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 */

#include <sys/signalfd.h>
#include <config.h>

#include "media_config.hpp"

#include <glibmm.h>
#include <fstream>
#include <iostream>
#include <boost/filesystem.hpp>
#include <version.hpp>
#include "httpendpointserver.hpp"
#include <ModuleLoader.hpp>
#include <glib/gstdio.h>

#include "services/Service.hpp"
#include "services/ServiceFactory.hpp"

#define GST_CAT_DEFAULT kurento_media_server
GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
#define GST_DEFAULT_NAME "KurentoMediaServer"

#define ENV_VAR "GST_PLUGIN_PATH"
#define CERTTOOL_TEMPLATE "autoCerttool.tmpl"
#define CERT_KEY_PEM_FILE "autoCertkey.pem"

using namespace ::kurento;

using boost::shared_ptr;
using namespace boost::filesystem;

using ::Glib::KeyFile;
using ::Glib::KeyFileFlags;

static Service *service;

GstSDPMessage *sdpPattern;
KmsHttpEPServer *httpepserver;
std::string stunServerAddress, pemCertificate;
gint stunServerPort;

Glib::RefPtr<Glib::MainLoop> loop = Glib::MainLoop::create ();

static gchar *conf_file;
gchar *autogenerated_pem_file, *template_path;

static GOptionEntry entries[] = {
  {
    "conf-file", 'f', 0, G_OPTION_ARG_FILENAME, &conf_file, "Configuration file",
    NULL
  },
  {NULL}
};

Glib::RefPtr<Glib::IOChannel> channel;

static void
check_port (int port)
{
  if (port <= 0 || port > G_MAXUSHORT) {
    throw Glib::KeyFileError (Glib::KeyFileError::PARSE, "Invalid value");
  }
}

static gchar *
read_entire_file (const gchar *file_name)
{
  gchar *data;
  long f_size;
  FILE *fp;

  fp = fopen (file_name, "r");

  if (fp == NULL) {
    return NULL;
  }

  fseek (fp, 0, SEEK_END);
  f_size = ftell (fp);
  fseek (fp, 0, SEEK_SET);
  data = (gchar *) g_malloc0 (f_size + 1);

  if (fread (data, 1, f_size, fp) != (size_t) f_size) {
    GST_ERROR ("Error reading file");
  }

  fclose (fp);

  data[f_size] = '\0';

  return data;
}

static GstSDPMessage *
load_sdp_pattern (Glib::KeyFile &configFile, const std::string &confFileName)
{
  GstSDPResult result;
  GstSDPMessage *sdp_pattern = NULL;
  gchar *sdp_pattern_text;
  std::string sdp_pattern_file_name;

  GST_DEBUG ("Load SDP Pattern");
  result = gst_sdp_message_new (&sdp_pattern);

  if (result != GST_SDP_OK) {
    GST_ERROR ("Error creating sdp message");
    return NULL;
  }

  sdp_pattern_file_name = configFile.get_string (SERVER_GROUP, SDP_PATTERN_KEY);
  boost::filesystem::path p (confFileName.c_str () );
  sdp_pattern_file_name.insert (0, "/");
  sdp_pattern_file_name.insert (0, p.parent_path ().c_str() );
  sdp_pattern_text = read_entire_file (sdp_pattern_file_name.c_str () );

  if (sdp_pattern_text == NULL) {
    GST_ERROR ("Error reading SDP pattern file");
    gst_sdp_message_free (sdp_pattern);
    return NULL;
  }

  result = gst_sdp_message_parse_buffer ( (const guint8 *) sdp_pattern_text, -1,
                                          sdp_pattern);
  g_free (sdp_pattern_text);

  if (result != GST_SDP_OK) {
    GST_ERROR ("Error parsing SDP config pattern");
    gst_sdp_message_free (sdp_pattern);
    return NULL;
  }

  return sdp_pattern;
}

static void
configure_kurento_media_server (KeyFile &configFile,
                                const std::string &file_name)
{
  gchar *sdpMessageText = NULL;

  try {
    sdpPattern = load_sdp_pattern (configFile, file_name);
    GST_DEBUG ("SDP: \n%s", sdpMessageText = gst_sdp_message_as_text (sdpPattern) );
    g_free (sdpMessageText);
  } catch (const Glib::KeyFileError &err) {
    GST_ERROR ("%s", err.what ().c_str () );
    GST_WARNING ("Wrong codec configuration, communication won't be possible");
  }

  service = ServiceFactory::create_service (configFile);
}

static gchar *
generate_certkey_pem_file (const gchar *dir)
{
  gchar *cmd, *pem_path;
  int ret;

  if (dir == NULL) {
    return NULL;
  }

  pem_path = g_strdup_printf ("%s/%s", dir, CERT_KEY_PEM_FILE);
  cmd =
    g_strconcat ("/bin/sh -c \"certtool --generate-privkey --outfile ",
                 pem_path, "\"", NULL);
  ret = system (cmd);
  g_free (cmd);

  if (ret == -1) {
    goto err;
  }

  template_path = g_strdup_printf ("%s/%s", dir, CERTTOOL_TEMPLATE);
  cmd =
    g_strconcat
    ("/bin/sh -c \"echo 'organization = kurento' > ", template_path,
     " && certtool --generate-self-signed --load-privkey ", pem_path,
     " --template ", template_path, " >> ", pem_path, " 2>/dev/null\"", NULL);
  ret = system (cmd);
  g_free (cmd);

  if (ret == -1) {
    goto err;
  }

  return pem_path;

err:

  GST_ERROR ("Error while generating certificate file");

  g_free (pem_path);
  return NULL;
}

static void
configure_web_rtc_end_point (KeyFile &configFile, const std::string &file_name)
{
  gint port;
  std::string pem_certificate_file_name;

  try {
    stunServerAddress = configFile.get_string (WEB_RTC_END_POINT_GROUP,
                        WEB_RTC_END_POINT_STUN_SERVER_ADDRESS_KEY);
  } catch (const Glib::KeyFileError &err) {
    GST_ERROR ("%s", err.what ().c_str () );
    GST_WARNING ("Setting default address %s to stun server",
                 STUN_SERVER_ADDRESS);
    stunServerAddress = STUN_SERVER_ADDRESS;
  }

  try {
    port = configFile.get_integer (WEB_RTC_END_POINT_GROUP,
                                   WEB_RTC_END_POINT_STUN_SERVER_PORT_KEY);
    check_port (port);
    stunServerPort = port;
  } catch (const Glib::KeyFileError &err) {
    GST_ERROR ("%s", err.what ().c_str () );
    GST_WARNING ("Setting default port %d to stun server",
                 STUN_SERVER_PORT);
    stunServerPort = STUN_SERVER_PORT;
  }

  try {
    pem_certificate_file_name = configFile.get_string (WEB_RTC_END_POINT_GROUP,
                                WEB_RTC_END_POINT_PEM_CERTIFICATE_KEY);
    boost::filesystem::path p (file_name.c_str () );
    pem_certificate_file_name.insert (0, "/");
    pem_certificate_file_name.insert (0, p.parent_path ().c_str() );
    pemCertificate = pem_certificate_file_name.c_str();

  } catch (const Glib::KeyFileError &err) {
    //generate a valid pem certificate
    autogenerated_pem_file = generate_certkey_pem_file ("/tmp/");

    if (autogenerated_pem_file == NULL ) {
      pemCertificate = "";
      GST_ERROR ("%s", err.what ().c_str () );
      GST_WARNING ("Could not create Pem Certificate or Pem Certificate not found");
    } else {
      pemCertificate = autogenerated_pem_file;
    }
  }
}

static void
load_config (const std::string &file_name)
{
  KeyFile configFile;

  GST_INFO ("Reading configuration from: %s", file_name.c_str () );

  try {
    configFile.load_from_file (file_name,
                               KeyFileFlags::KEY_FILE_KEEP_COMMENTS |
                               KeyFileFlags::KEY_FILE_KEEP_TRANSLATIONS);
  } catch (const Glib::Error &ex) {
    GST_ERROR ("Error loading configuration: %s", ex.what ().c_str () );
    throw ex;
  }

  /* parse options so as to configure services */
  configure_kurento_media_server (configFile, file_name);
  configure_web_rtc_end_point (configFile, file_name);

  GST_INFO ("Configuration loaded successfully");
}

static bool
signal_handler (Glib::IOCondition cond)
{
  static unsigned int __terminated = 0;
  struct signalfd_siginfo si;
  gsize bytes_read, count = sizeof (si);
  Glib::IOStatus status;

  if (cond & (Glib::IO_NVAL | Glib::IO_ERR | Glib::IO_HUP) ) {
    return false;
  }

  /* Read signal info */
  status = channel->read ( (char *) &si, count, bytes_read);

  switch (status) {
  case Glib::IO_STATUS_ERROR:
    GST_ERROR ("Error occurred.");
    return false;

  case Glib::IO_STATUS_EOF:
    GST_DEBUG ("End of file.");
    return false;

  case Glib::IO_STATUS_AGAIN:
    GST_DEBUG ("Resource temporarily unavailable.");
    return false;

  case Glib::IO_STATUS_NORMAL:
    if (bytes_read != count) {
      GST_DEBUG ("Could not read siginfo structure");
      return false;
    }

    break;
  }

  /* Manage signal */
  switch (si.ssi_signo) {
  case SIGINT:
  case SIGTERM:
    if (__terminated == 0) {
      GST_DEBUG ("Terminating.");
      loop->quit ();
    }

    __terminated = 1;
    break;

  case SIGPIPE:
    GST_DEBUG ("Ignore sigpipe signal");
    return false;

  case SIGSEGV:
    GST_DEBUG ("Segmentation fault. Aborting process execution");
    abort ();

  default:
    break;
  }

  return true;
}

static Glib::RefPtr<Glib::IOSource>
setup_signalfd ()
{
  Glib::RefPtr<Glib::IOSource> source;
  sigset_t mask;
  int fd;

  sigemptyset (&mask);
  sigaddset (&mask, SIGINT);
  sigaddset (&mask, SIGTERM);
  sigaddset (&mask, SIGSEGV);
  sigaddset (&mask, SIGPIPE);

  if (sigprocmask (SIG_BLOCK, &mask, NULL) < 0) {
    throw "Failed to set signal mask";
  }

  fd = signalfd (-1, &mask, 0);

  if (fd < 0) {
    throw "Failed to create signal descriptor";
  }

  channel = Glib::IOChannel::create_from_fd (fd);
  channel->set_close_on_unref (true);
  channel->set_encoding ("");
  channel->set_buffered (false);

  source = channel->create_watch (Glib::IO_IN | Glib::IO_HUP | Glib::IO_ERR |
                                  Glib::IO_NVAL);
  source->connect (sigc::ptr_fun (&signal_handler) );

  return source;
}

static void
deleteCertificate ()
{
  //delete pem certificate
  if (autogenerated_pem_file != NULL) {
    int rv = g_remove (autogenerated_pem_file);

    if (rv) {
      GST_WARNING ("Error deleting file: %s. %s", autogenerated_pem_file,
                   strerror (errno) );
    }

    g_free (autogenerated_pem_file);
  }

  if (template_path != NULL) {
    int rv = g_remove (template_path);

    if (rv) {
      GST_WARNING ("Error deleting file: %s. %s", template_path, strerror (errno) );
    }

    g_free (template_path);
  }
}

static void
check_if_plugins_are_available ()
{
  GstPlugin *plugin = gst_plugin_load_by_name ("kurento");

  if (plugin == NULL) {
    g_printerr ("Kurento plugin not found, try adding the plugins route with "
                "--gst-plugin-path parameter. See help (--help-gst) "
                "for more info\n");
    exit (1);
  }

  g_clear_object (&plugin);
}

int
main (int argc, char **argv)
{
  Glib::RefPtr<Glib::Source> source;
  GError *error = NULL;
  GOptionContext *context;
  gchar *oldEnv, *newEnv;

  Glib::init();
  gst_init (&argc, &argv);
  GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, GST_DEFAULT_NAME, 0,
                           GST_DEFAULT_NAME);

  oldEnv = getenv (ENV_VAR);

  if (oldEnv == NULL) {
    newEnv = g_strdup_printf ("%s", PLUGIN_PATH);
  } else {
    newEnv = g_strdup_printf ("%s:%s", oldEnv, PLUGIN_PATH);
  }

  setenv (ENV_VAR, newEnv, 1);
  g_free (newEnv);

  check_if_plugins_are_available ();

  context = g_option_context_new ("");
  g_option_context_add_main_entries (context, entries, NULL);
  g_option_context_add_group (context, gst_init_get_option_group () );

  if (!g_option_context_parse (context, &argc, &argv, &error) ) {
    // TODO: Free context
    g_printerr ("option parsing failed: %s\n", error->message);
    g_error_free (error);
    exit (1);
  }

  g_option_context_free (context);

  /* Install our signal handler */
  source = setup_signalfd();
  source->attach (Glib::MainContext::get_default() );

  GST_INFO ("Kmsc version: %s", get_version () );

  if (!conf_file) {
    load_config (DEFAULT_CONFIG_FILE);
  } else {
    load_config ( (std::string) conf_file);
  }

  /* Start service */
  service->start ();

  loop->run ();

  source->destroy();

  deleteCertificate ();

  service->stop();

  g_object_unref (G_OBJECT (httpepserver) );
  delete service;

  return 0;
}

/* Autogenerated with Kurento Idl */

#include <memory>

#include "MediaSource.hpp"
#include "MediaType.hpp"
#include "MediaSource.hpp"
#include "MediaType.hpp"
#include "MediaSource.hpp"
#include "MediaSink.hpp"
#include "MediaType.hpp"
#include "MediaSink.hpp"
#include "MediaType.hpp"
#include "MediaSink.hpp"
#include "MediaType.hpp"
#include "MediaElement.hpp"
#include "MediaType.hpp"
#include "MediaElement.hpp"
#include "MediaElement.hpp"
#include <JsonSerializer.hpp>

namespace kurento {


void
MediaElement::Invoker::invoke (std::shared_ptr<MediaObject> obj,
    const std::string &methodName, const Json::Value &params,
    Json::Value &response)
{
  if (methodName == "getMediaSrcs" && params.size() == 0) {
    Json::Value aux;
    std::vector<std::shared_ptr<MediaSource>> ret;
    JsonSerializer serializer(true);

    // TODO: Implement method getMediaSrcs
    std::shared_ptr<MediaElement> finalObj;
    finalObj = std::dynamic_pointer_cast<MediaElement> (obj);
    if (!finalObj) {
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "Object not found or has incorrect type");
      throw e;
    }

    ret =finalObj->getMediaSrcs ();
    serializer.SerializeNVP (ret);
    response = serializer.JsonValue["ret"];
    return;
  }

  if (methodName == "getMediaSrcs" && params.size() == 2) {
    Json::Value aux;
    std::vector<std::shared_ptr<MediaSource>> ret;
    JsonSerializer serializer(true);
    std::shared_ptr<MediaType> mediaType;
    std::string description;

    if (!params.isMember ("mediaType")) {
      /* param 'mediaType' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter is requiered");
      throw e;
    } else {
      aux = params["mediaType"];

      if (!aux.isString ()) {
        /* param 'mediaType' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter should be a string");
        throw e;
      }

      mediaType = std::shared_ptr<MediaType> (new MediaType (aux.asString ()));
    }

    if (!params.isMember ("description")) {
      /* param 'description' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'description' parameter is requiered");
      throw e;
    } else {
      aux = params["description"];

      if (!aux.isString ()) {
        /* param 'description' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'description' parameter should be a string");
        throw e;
      }

      description = aux.asString ();
    }

    // TODO: Implement method getMediaSrcs
    std::shared_ptr<MediaElement> finalObj;
    finalObj = std::dynamic_pointer_cast<MediaElement> (obj);
    if (!finalObj) {
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "Object not found or has incorrect type");
      throw e;
    }

    ret =finalObj->getMediaSrcs (mediaType, description);
    serializer.SerializeNVP (ret);
    response = serializer.JsonValue["ret"];
    return;
  }

  if (methodName == "getMediaSrcs" && params.size() == 1) {
    Json::Value aux;
    std::vector<std::shared_ptr<MediaSource>> ret;
    JsonSerializer serializer(true);
    std::shared_ptr<MediaType> mediaType;

    if (!params.isMember ("mediaType")) {
      /* param 'mediaType' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter is requiered");
      throw e;
    } else {
      aux = params["mediaType"];

      if (!aux.isString ()) {
        /* param 'mediaType' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter should be a string");
        throw e;
      }

      mediaType = std::shared_ptr<MediaType> (new MediaType (aux.asString ()));
    }

    // TODO: Implement method getMediaSrcs
    std::shared_ptr<MediaElement> finalObj;
    finalObj = std::dynamic_pointer_cast<MediaElement> (obj);
    if (!finalObj) {
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "Object not found or has incorrect type");
      throw e;
    }

    ret =finalObj->getMediaSrcs (mediaType);
    serializer.SerializeNVP (ret);
    response = serializer.JsonValue["ret"];
    return;
  }

  if (methodName == "getMediaSinks" && params.size() == 0) {
    Json::Value aux;
    std::vector<std::shared_ptr<MediaSink>> ret;
    JsonSerializer serializer(true);

    // TODO: Implement method getMediaSinks
    std::shared_ptr<MediaElement> finalObj;
    finalObj = std::dynamic_pointer_cast<MediaElement> (obj);
    if (!finalObj) {
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "Object not found or has incorrect type");
      throw e;
    }

    ret =finalObj->getMediaSinks ();
    serializer.SerializeNVP (ret);
    response = serializer.JsonValue["ret"];
    return;
  }

  if (methodName == "getMediaSinks" && params.size() == 1) {
    Json::Value aux;
    std::vector<std::shared_ptr<MediaSink>> ret;
    JsonSerializer serializer(true);
    std::shared_ptr<MediaType> mediaType;

    if (!params.isMember ("mediaType")) {
      /* param 'mediaType' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter is requiered");
      throw e;
    } else {
      aux = params["mediaType"];

      if (!aux.isString ()) {
        /* param 'mediaType' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter should be a string");
        throw e;
      }

      mediaType = std::shared_ptr<MediaType> (new MediaType (aux.asString ()));
    }

    // TODO: Implement method getMediaSinks
    std::shared_ptr<MediaElement> finalObj;
    finalObj = std::dynamic_pointer_cast<MediaElement> (obj);
    if (!finalObj) {
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "Object not found or has incorrect type");
      throw e;
    }

    ret =finalObj->getMediaSinks (mediaType);
    serializer.SerializeNVP (ret);
    response = serializer.JsonValue["ret"];
    return;
  }

  if (methodName == "getMediaSinks" && params.size() == 2) {
    Json::Value aux;
    std::vector<std::shared_ptr<MediaSink>> ret;
    JsonSerializer serializer(true);
    std::shared_ptr<MediaType> mediaType;
    std::string description;

    if (!params.isMember ("mediaType")) {
      /* param 'mediaType' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter is requiered");
      throw e;
    } else {
      aux = params["mediaType"];

      if (!aux.isString ()) {
        /* param 'mediaType' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter should be a string");
        throw e;
      }

      mediaType = std::shared_ptr<MediaType> (new MediaType (aux.asString ()));
    }

    if (!params.isMember ("description")) {
      /* param 'description' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'description' parameter is requiered");
      throw e;
    } else {
      aux = params["description"];

      if (!aux.isString ()) {
        /* param 'description' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'description' parameter should be a string");
        throw e;
      }

      description = aux.asString ();
    }

    // TODO: Implement method getMediaSinks
    std::shared_ptr<MediaElement> finalObj;
    finalObj = std::dynamic_pointer_cast<MediaElement> (obj);
    if (!finalObj) {
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "Object not found or has incorrect type");
      throw e;
    }

    ret =finalObj->getMediaSinks (mediaType, description);
    serializer.SerializeNVP (ret);
    response = serializer.JsonValue["ret"];
    return;
  }

  if (methodName == "connect" && params.size() == 3) {
    Json::Value aux;
    std::shared_ptr<MediaElement> sink;
    std::shared_ptr<MediaType> mediaType;
    std::string mediaDescription;

    if (!params.isMember ("sink")) {
      /* param 'sink' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' parameter is requiered");
      throw e;
    } else {
      std::shared_ptr<MediaObject> obj;

      aux = params["sink"];

      if (!aux.isString ()) {
        /* param 'sink' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' parameter should be a string");
        throw e;
      }

      try {
        obj = MediaElement::Factory::getObject (aux.asString ());
      } catch (JsonRpc::CallException &ex) {
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' object not found: "+ ex.getMessage());
        throw e;
      }

      sink = std::dynamic_pointer_cast<MediaElement> (obj);

      if (!sink) {
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' object has a invalid type");
        throw e;
      }
    }

    if (!params.isMember ("mediaType")) {
      /* param 'mediaType' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter is requiered");
      throw e;
    } else {
      aux = params["mediaType"];

      if (!aux.isString ()) {
        /* param 'mediaType' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter should be a string");
        throw e;
      }

      mediaType = std::shared_ptr<MediaType> (new MediaType (aux.asString ()));
    }

    if (!params.isMember ("mediaDescription")) {
      /* param 'mediaDescription' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaDescription' parameter is requiered");
      throw e;
    } else {
      aux = params["mediaDescription"];

      if (!aux.isString ()) {
        /* param 'mediaDescription' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaDescription' parameter should be a string");
        throw e;
      }

      mediaDescription = aux.asString ();
    }

    // TODO: Implement method connect
    std::shared_ptr<MediaElement> finalObj;
    finalObj = std::dynamic_pointer_cast<MediaElement> (obj);
    if (!finalObj) {
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "Object not found or has incorrect type");
      throw e;
    }

    finalObj->connect (sink, mediaType, mediaDescription);
    return;
  }

  if (methodName == "connect" && params.size() == 2) {
    Json::Value aux;
    std::shared_ptr<MediaElement> sink;
    std::shared_ptr<MediaType> mediaType;

    if (!params.isMember ("sink")) {
      /* param 'sink' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' parameter is requiered");
      throw e;
    } else {
      std::shared_ptr<MediaObject> obj;

      aux = params["sink"];

      if (!aux.isString ()) {
        /* param 'sink' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' parameter should be a string");
        throw e;
      }

      try {
        obj = MediaElement::Factory::getObject (aux.asString ());
      } catch (JsonRpc::CallException &ex) {
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' object not found: "+ ex.getMessage());
        throw e;
      }

      sink = std::dynamic_pointer_cast<MediaElement> (obj);

      if (!sink) {
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' object has a invalid type");
        throw e;
      }
    }

    if (!params.isMember ("mediaType")) {
      /* param 'mediaType' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter is requiered");
      throw e;
    } else {
      aux = params["mediaType"];

      if (!aux.isString ()) {
        /* param 'mediaType' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'mediaType' parameter should be a string");
        throw e;
      }

      mediaType = std::shared_ptr<MediaType> (new MediaType (aux.asString ()));
    }

    // TODO: Implement method connect
    std::shared_ptr<MediaElement> finalObj;
    finalObj = std::dynamic_pointer_cast<MediaElement> (obj);
    if (!finalObj) {
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "Object not found or has incorrect type");
      throw e;
    }

    finalObj->connect (sink, mediaType);
    return;
  }

  if (methodName == "connect" && params.size() == 1) {
    Json::Value aux;
    std::shared_ptr<MediaElement> sink;

    if (!params.isMember ("sink")) {
      /* param 'sink' not present, raise exception */
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' parameter is requiered");
      throw e;
    } else {
      std::shared_ptr<MediaObject> obj;

      aux = params["sink"];

      if (!aux.isString ()) {
        /* param 'sink' has invalid type value, raise exception */
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' parameter should be a string");
        throw e;
      }

      try {
        obj = MediaElement::Factory::getObject (aux.asString ());
      } catch (JsonRpc::CallException &ex) {
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' object not found: "+ ex.getMessage());
        throw e;
      }

      sink = std::dynamic_pointer_cast<MediaElement> (obj);

      if (!sink) {
        JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "'sink' object has a invalid type");
        throw e;
      }
    }

    // TODO: Implement method connect
    std::shared_ptr<MediaElement> finalObj;
    finalObj = std::dynamic_pointer_cast<MediaElement> (obj);
    if (!finalObj) {
      JsonRpc::CallException e (JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                                "Object not found or has incorrect type");
      throw e;
    }

    finalObj->connect (sink);
    return;
  }

  MediaObject::Invoker::invoke(obj, methodName, params, response);
}

std::string
MediaElement::connect(const std::string &eventType, std::shared_ptr<EventHandler> handler)
{
  return MediaObject::connect (eventType, handler);
}

} /* kurento */

void
Serialize(std::shared_ptr<kurento::MediaElement> &object, JsonSerializer &serializer)
{
  if (!serializer.IsWriter) {
    try {
      std::shared_ptr<kurento::MediaObject> aux;
      aux = kurento::MediaElement::Factory::getObject (serializer.JsonValue.asString ());
      object = std::dynamic_pointer_cast<kurento::MediaElement> (aux);
      return;
    } catch (kurento::JsonRpc::CallException &ex) {
      kurento::JsonRpc::CallException e (kurento::JsonRpc::ErrorCode::SERVER_ERROR_INIT,
                              "'MediaElement' object not found: "+ ex.getMessage());
      throw e;
    }
  }
  std::shared_ptr<kurento::MediaObject> aux = std::dynamic_pointer_cast<kurento::MediaObject> (object);

  void Serialize(std::shared_ptr<kurento::MediaObject> &object, JsonSerializer &serializer);
  Serialize(aux, serializer);
}

void
Serialize(kurento::MediaElement &object, JsonSerializer &serializer)
{
  void Serialize(kurento::MediaObject &object, JsonSerializer &serializer);
  try {
    Serialize(dynamic_cast<kurento::MediaObject &> (object), serializer);
  } catch (std::bad_cast) {
  }
}
